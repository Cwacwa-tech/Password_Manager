{"version":3,"file":"background.js","mappings":"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","sources":["webpack://browser-extension/./src/common.ts","webpack://browser-extension/webpack/bootstrap","webpack://browser-extension/./src/background.ts"],"sourcesContent":["export function setBadgeText(enabled: boolean) {\n    const text = enabled ? \"ON\" : \"OFF\"\n    void chrome.action.setBadgeText({text: text})\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {setBadgeText} from \"./common\"\n// Set the badge text to \"ON\" when the background script starts.\nsetBadgeText(true);\n\n/**\n * Retrieves authentication token from Chrome storage\n * @param {Object} options - Configuration options\n * @param {boolean} options.autoRefresh - Whether to attempt token refresh if expired (default: false)\n * @param {number} options.retryCount - Number of retries on failure (default: 0)\n * @param {number} options.retryDelay - Delay between retries in ms (default: 500)\n * @returns {Promise<string>} The authentication token\n */\n/**\n * Options for the getAuthToken function\n */\ninterface AuthTokenOptions {\n    /** Whether to attempt token refresh if expired */\n    autoRefresh?: boolean;\n    /** Number of retries on failure */\n    retryCount?: number;\n    /** Delay between retries in ms */\n    retryDelay?: number;\n  }\n  \n  /**\n   * Retrieves authentication token from Chrome storage\n   * @param options - Configuration options\n   * @returns The authentication token\n   */\n  function getAuthToken(options: AuthTokenOptions = {}): Promise<string> {\n    const {\n      autoRefresh = false,\n      retryCount = 0,\n      retryDelay = 500\n    } = options;\n    \n    let attempts = 0;\n  \n    const attemptGetToken = (): Promise<string> => {\n      return new Promise((resolve, reject) => {\n        chrome.storage.local.get(['authData'], (result) => {\n          // Handle Chrome runtime errors\n          if (chrome.runtime.lastError) {\n            console.error('Chrome runtime error:', chrome.runtime.lastError.message);\n            reject(new Error(chrome.runtime.lastError.message));\n            return;\n          }\n  \n          // Validate auth data exists and has required structure\n          if (!result || typeof result !== 'object') {\n            reject(new Error('Invalid storage data format'));\n            return;\n          }\n  \n          const authData = result.authData;\n          \n          // Check if auth data exists\n          if (!authData) {\n            reject(new Error('No authentication data found'));\n            return;\n          }\n  \n          // Check if token exists\n          if (!authData.token || typeof authData.token !== 'string') {\n            reject(new Error('No valid authentication token found'));\n            return;\n          }\n  \n          // Check if token is expired\n          const isExpired = authData.expires && typeof authData.expires === 'number' && \n                            Date.now() > authData.expires;\n          \n          // Handle expired token\n          if (isExpired) {\n            if (autoRefresh && typeof authData.refreshToken === 'string') {\n              // Here you would implement refresh token logic\n              console.log('Token expired, attempting refresh');\n              // This is a placeholder - actual refresh implementation would go here\n              // refreshAuthToken(authData.refreshToken).then(resolve).catch(reject);\n              reject(new Error('Token expired - refresh not implemented'));\n            } else {\n              reject(new Error('Authentication token has expired'));\n            }\n            return;\n          }\n  \n          // Success - return valid token\n          resolve(authData.token);\n        });\n      });\n    };\n  \n    // Function for handling retries\n    const executeWithRetry = (): Promise<string> => {\n      return attemptGetToken().catch(error => {\n        attempts++;\n        if (attempts <= retryCount) {\n          console.log(`Retry attempt ${attempts}/${retryCount} after error: ${error.message}`);\n          return new Promise(resolve => setTimeout(resolve, retryDelay))\n            .then(executeWithRetry);\n        }\n        throw error; // If all retries fail, propagate the error\n      });\n    };\n  \n    return executeWithRetry();\n  }\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === \"generate_password\") {\n        // Send the request to the backend to generate a password\n        fetch('http://localhost:8000/password/generate', {\n            method: 'GET',  // Or POST if necessary, depending on your backend setup\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        })\n            .then((response) => response.json())  // Assuming the backend returns a JSON response\n            .then((data) => {\n                if (data.password) {\n                    // Send the generated password to the popup\n                    sendResponse({ password: data.password });\n                } else {\n                    sendResponse({ error: 'Failed to generate password' });\n                }\n            })\n            .catch((error) => {\n                console.error('Error generating password:', error);\n                sendResponse({ error: 'Failed to contact backend' });\n            });\n\n        // Keep the response channel open until the async operation finishes\n        return true;\n    }\n\n    if (message.action === \"login\") {\n        // Forward the login request to the Backend\n        const loginData = new URLSearchParams();\n        loginData.append(\"username\", message.email);\n        loginData.append(\"password\", message.masterPassword);\n\n        fetch('http://localhost:8000/auth/login', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            body: loginData.toString(),\n        })\n        .then(response => response.json())\n        .then(data => {\n            if (data.access_token) {\n                // Store the token in chrome storage for later use\n                const expiresIn = data.expires_in || 3600; // Default to 1 hour if not provided\n                chrome.storage.local.set({ \n                    authData: {\n                        token: data.access_token,\n                        expires: Date.now() + (expiresIn * 1000),\n                        refreshToken: data.refresh_token || null\n                    }\n                }, () => {\n                    console.log(\"Token stored successfully.\");\n                });\n\n                sendResponse({ success: true, token: data.access_token });\n            } else {\n                sendResponse({ success: false, error: data.detail || \"Login failed\" });\n            }\n        })\n        .catch(error => {\n            console.error(\"Login error:\", error);\n            sendResponse({ success: false, error: \"Failed to contact backend\" });\n        });\n\n        return true; // Keep response channel open\n    }\n    if (message.action === 'saveCredentials') {\n        // Get the credentials from the message\n        const credentials = message.data;\n        \n        // First get the token, then use it in the fetch request\n        getAuthToken()\n            .then(token => {\n                // Send to your backend with the token\n                return fetch('http://localhost:8000/vault/passwords', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': 'Bearer ' + token\n                    },\n                    body: JSON.stringify(credentials)\n                });\n            })\n            .then(response => {\n                // Check if response is OK before parsing JSON\n                if (!response.ok && response.status !== 200) {\n                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);\n                }\n                return response.json();\n            })\n            .then(data => {\n                // Check if the response contains a duplicate message\n                if (data.message === \"Password already saved!\") {\n                    sendResponse({ \n                        success: true, \n                        message: 'Password already saved!' \n                    });\n                } else {\n                    sendResponse({ \n                        success: true, \n                        message: 'Credentials saved successfully' \n                    });\n                }\n            })\n            .catch(error => {\n                console.error('Error saving credentials:', error);\n                sendResponse({ \n                    success: false, \n                    message: 'Failed to save credentials' \n                });\n            });\n        \n        // Required for async response\n        return true;\n    }\n});"],"names":["enabled","text","chrome","action","setBadgeText","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","runtime","onMessage","addListener","message","sender","sendResponse","fetch","method","headers","then","response","json","data","password","error","catch","console","loginData","URLSearchParams","append","email","masterPassword","body","toString","access_token","expiresIn","expires_in","storage","local","set","authData","token","expires","Date","now","refreshToken","refresh_token","log","success","detail","credentials","options","autoRefresh","retryCount","retryDelay","attempts","executeWithRetry","Promise","resolve","reject","get","result","lastError","Error","setTimeout","getAuthToken","JSON","stringify","ok","status","statusText"],"sourceRoot":""}