{"version":3,"file":"background.js","mappings":"uFAAA,wBAA6BA,GACzB,MAAMC,EAAOD,EAAU,KAAO,MACzBE,OAAOC,OAAOC,aAAa,CAACH,KAAMA,GAC3C,EAGA,6BAAkCI,EAAyBC,G,MAEvD,GAAID,EAAME,UAAYF,EAAMG,SAAU,OAEtC,MAAMC,EAAoG,QAA3E,EAAAC,OAAOC,yBAAyBC,OAAOC,iBAAiBC,UAAW,gBAAQ,eAAEC,IACxGN,EACAA,EAAuBO,KAAKX,EAAOC,GAGnCD,EAAMC,MAAQA,EAIH,CAAC,QAAS,SAAU,UAAW,SAEvCW,SAAQC,IACX,IAAIC,EAGAA,EAFc,YAAdD,GAAyC,UAAdA,EAEnB,IAAIE,cAAcF,EAAW,CACjCG,SAAS,EACTC,YAAY,EACZC,IAAK,MAID,IAAIC,MAAMN,EAAW,CAAEG,SAAS,IAE5ChB,EAAMoB,cAAcN,EAAM,IAI9Bd,EAAMqB,QACNC,YAAW,KACPtB,EAAMuB,MAAM,GACb,IACP,C,GCzCIC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,C,MCOE,SAASG,EAAaC,EAA4B,CAAC,GACjD,MAAM,YACJC,GAAc,EAAK,WACnBC,EAAa,EAAC,WACdC,EAAa,KACXH,EAEJ,IAAII,EAAW,EAEf,MAuDMC,EAAmB,IAtDhB,IAAIC,SAAQ,CAACC,EAASC,KAC3B5C,OAAO6C,QAAQC,MAAMC,IAAI,CAAC,aAAcC,IAEtC,GAAIhD,OAAOiD,QAAQC,UAGjB,OAFAC,QAAQC,MAAM,wBAAyBpD,OAAOiD,QAAQC,UAAUG,cAChET,EAAO,IAAIU,MAAMtD,OAAOiD,QAAQC,UAAUG,UAK5C,IAAKL,GAA4B,iBAAXA,EAEpB,YADAJ,EAAO,IAAIU,MAAM,gCAInB,MAAMC,EAAWP,EAAOO,SAGnBA,EAMAA,EAASC,OAAmC,iBAAnBD,EAASC,MAMrBD,EAASE,SAAuC,iBAArBF,EAASE,SACpCC,KAAKC,MAAQJ,EAASE,QAIlCpB,GAAgD,iBAA1BkB,EAASK,cAEjCT,QAAQU,IAAI,qCAGZjB,EAAO,IAAIU,MAAM,6CAEjBV,EAAO,IAAIU,MAAM,qCAMrBX,EAAQY,EAASC,OAvBfZ,EAAO,IAAIU,MAAM,wCANjBV,EAAO,IAAIU,MAAM,gCA6BI,GACvB,IAMqBQ,OAAMV,IAE7B,GADAZ,IACIA,GAAYF,EAEd,OADAa,QAAQU,IAAI,iBAAiBrB,KAAYF,kBAA2Bc,EAAMC,WACnE,IAAIX,SAAQC,GAAWlB,WAAWkB,EAASJ,KAC/CwB,KAAKtB,GAEV,MAAMW,CAAK,IAIf,OAAOX,GACT,EAxGF,EAFA,OAEAvC,eAAa,GA0GbF,OAAOiD,QAAQe,UAAUC,aAAY,CAACZ,EAASa,EAAQC,KACnD,GAAuB,sBAAnBd,EAAQpD,OAuBR,OArBAmE,MAAM,0CAA2C,CAC7CC,OAAQ,MACRC,QAAS,CACL,eAAgB,sBAGnBP,MAAMQ,GAAaA,EAASC,SAC5BT,MAAMU,IACCA,EAAKC,SAELP,EAAa,CAAEO,SAAUD,EAAKC,WAE9BP,EAAa,CAAEf,MAAO,+BAC1B,IAEHU,OAAOV,IACJD,QAAQC,MAAM,6BAA8BA,GAC5Ce,EAAa,CAAEf,MAAO,6BAA8B,KAIrD,EAGX,GAAuB,UAAnBC,EAAQpD,OAAoB,CAE5B,MAAM0E,EAAY,IAAIC,gBAkCtB,OAjCAD,EAAUE,OAAO,WAAYxB,EAAQyB,OACrCH,EAAUE,OAAO,WAAYxB,EAAQ0B,gBAErCX,MAAM,mCAAoC,CACtCC,OAAQ,OACRC,QAAS,CAAE,eAAgB,qCAC3BU,KAAML,EAAUM,aAEnBlB,MAAKQ,GAAYA,EAASC,SAC1BT,MAAKU,IACF,GAAIA,EAAKS,aAAc,CAEnB,MAAMC,EAAYV,EAAKW,YAAc,KACrCpF,OAAO6C,QAAQC,MAAMjC,IAAI,CACrB0C,SAAU,CACNC,MAAOiB,EAAKS,aACZzB,QAASC,KAAKC,MAAqB,IAAZwB,EACvBvB,aAAca,EAAKY,eAAiB,QAEzC,KACClC,QAAQU,IAAI,6BAA6B,IAG7CM,EAAa,CAAEmB,SAAS,EAAM9B,MAAOiB,EAAKS,cAC9C,MACIf,EAAa,CAAEmB,SAAS,EAAOlC,MAAOqB,EAAKc,QAAU,gBACzD,IAEHzB,OAAMV,IACHD,QAAQC,MAAM,eAAgBA,GAC9Be,EAAa,CAAEmB,SAAS,EAAOlC,MAAO,6BAA8B,KAGjE,CACX,CACA,GAAuB,oBAAnBC,EAAQpD,OAA8B,CAEtC,MAAMuF,EAAcnC,EAAQoB,KA6C5B,OA1CAtC,IACK4B,MAAKP,GAEKY,MAAM,wCAAyC,CAClDC,OAAQ,OACRC,QAAS,CACL,eAAgB,mBAChB,cAAiB,UAAYd,GAEjCwB,KAAMS,KAAKC,UAAUF,OAG5BzB,MAAKQ,IAEF,IAAKA,EAASoB,IAA0B,MAApBpB,EAASqB,OACzB,MAAM,IAAItC,MAAM,mBAAmBiB,EAASqB,WAAWrB,EAASsB,cAEpE,OAAOtB,EAASC,MAAM,IAEzBT,MAAKU,IAEmB,4BAAjBA,EAAKpB,QACLc,EAAa,CACTmB,SAAS,EACTjC,QAAS,4BAGbc,EAAa,CACTmB,SAAS,EACTjC,QAAS,kCAEjB,IAEHS,OAAMV,IACHD,QAAQC,MAAM,4BAA6BA,GAC3Ce,EAAa,CACTmB,SAAS,EACTjC,QAAS,8BACX,KAIH,CACX,CAEA,GAAuB,mBAAnBA,EAAQpD,OAA6B,CACrC,MAAM6F,EAAOzC,EAAQyC,KAgCrB,OA7BA3D,IACG4B,MAAKP,GACGY,MAAM,8CAA8C2B,mBAAmBD,KAAS,CACrFzB,OAAQ,MACRC,QAAS,CACP,cAAiB,UAAUd,SAIhCO,MAAKQ,IACJ,IAAKA,EAASoB,GACZ,MAAM,IAAIrC,MAAM,mBAAmBiB,EAASqB,WAAWrB,EAASsB,cAElE,OAAOtB,EAASC,MAAM,IAEvBT,MAAKU,IACJN,EAAa,CACXmB,SAAS,EACTE,YAAaf,GACb,IAEHX,OAAMV,IACLD,QAAQC,MAAM,8BAA+BA,GAC7Ce,EAAa,CACXmB,SAAS,EACTlC,MAAOA,EAAMC,SACb,KAGC,CACT,I","sources":["webpack://browser-extension/./src/common.ts","webpack://browser-extension/webpack/bootstrap","webpack://browser-extension/./src/background.ts"],"sourcesContent":["export function setBadgeText(enabled: boolean) {\n    const text = enabled ? \"ON\" : \"OFF\"\n    void chrome.action.setBadgeText({text: text})\n}\n\n// Function to simulate user input, ensuring frameworks (React, Vue) detect changes\nexport function simulateUserInput(input: HTMLInputElement, value: string) {\n    // Skip if input is disabled or readonly\n    if (input.disabled || input.readOnly) return;\n    \n    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, \"value\")?.set;\n    if (nativeInputValueSetter) {\n        nativeInputValueSetter.call(input, value); // Set input value programmatically\n    } else {\n        // Fallback if the setter is not available\n        input.value = value;\n    }\n\n    // Dispatch multiple events for maximum compatibility with different frameworks\n    const events = ['input', 'change', 'keydown', 'keyup'];\n    \n    events.forEach(eventType => {\n        let event;\n        if (eventType === 'keydown' || eventType === 'keyup') {\n            // For key events, create a KeyboardEvent\n            event = new KeyboardEvent(eventType, {\n                bubbles: true,\n                cancelable: true,\n                key: 'L' // First letter of \"LOVE\"\n            });\n        } else {\n            // For other events, use regular Event\n            event = new Event(eventType, { bubbles: true });\n        }\n        input.dispatchEvent(event);\n    });\n    \n    // Some frameworks might use focus/blur events as well\n    input.focus();\n    setTimeout(() => {\n        input.blur();\n    }, 100);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {setBadgeText} from \"./common\"\n// Set the badge text to \"ON\" when the background script starts.\nsetBadgeText(true);\n\n/**\n * Retrieves authentication token from Chrome storage\n * @param {Object} options - Configuration options\n * @param {boolean} options.autoRefresh - Whether to attempt token refresh if expired (default: false)\n * @param {number} options.retryCount - Number of retries on failure (default: 0)\n * @param {number} options.retryDelay - Delay between retries in ms (default: 500)\n * @returns {Promise<string>} The authentication token\n */\n/**\n * Options for the getAuthToken function\n */\ninterface AuthTokenOptions {\n    /** Whether to attempt token refresh if expired */\n    autoRefresh?: boolean;\n    /** Number of retries on failure */\n    retryCount?: number;\n    /** Delay between retries in ms */\n    retryDelay?: number;\n  }\n  \n  /**\n   * Retrieves authentication token from Chrome storage\n   * @param options - Configuration options\n   * @returns The authentication token\n   */\n  function getAuthToken(options: AuthTokenOptions = {}): Promise<string> {\n    const {\n      autoRefresh = false,\n      retryCount = 0,\n      retryDelay = 500\n    } = options;\n    \n    let attempts = 0;\n  \n    const attemptGetToken = (): Promise<string> => {\n      return new Promise((resolve, reject) => {\n        chrome.storage.local.get(['authData'], (result) => {\n          // Handle Chrome runtime errors\n          if (chrome.runtime.lastError) {\n            console.error('Chrome runtime error:', chrome.runtime.lastError.message);\n            reject(new Error(chrome.runtime.lastError.message));\n            return;\n          }\n  \n          // Validate auth data exists and has required structure\n          if (!result || typeof result !== 'object') {\n            reject(new Error('Invalid storage data format'));\n            return;\n          }\n  \n          const authData = result.authData;\n          \n          // Check if auth data exists\n          if (!authData) {\n            reject(new Error('No authentication data found'));\n            return;\n          }\n  \n          // Check if token exists\n          if (!authData.token || typeof authData.token !== 'string') {\n            reject(new Error('No valid authentication token found'));\n            return;\n          }\n  \n          // Check if token is expired\n          const isExpired = authData.expires && typeof authData.expires === 'number' && \n                            Date.now() > authData.expires;\n          \n          // Handle expired token\n          if (isExpired) {\n            if (autoRefresh && typeof authData.refreshToken === 'string') {\n              // Here you would implement refresh token logic\n              console.log('Token expired, attempting refresh');\n              // This is a placeholder - actual refresh implementation would go here\n              // refreshAuthToken(authData.refreshToken).then(resolve).catch(reject);\n              reject(new Error('Token expired - refresh not implemented'));\n            } else {\n              reject(new Error('Authentication token has expired'));\n            }\n            return;\n          }\n  \n          // Success - return valid token\n          resolve(authData.token);\n        });\n      });\n    };\n  \n    // Function for handling retries\n    const executeWithRetry = (): Promise<string> => {\n      return attemptGetToken().catch(error => {\n        attempts++;\n        if (attempts <= retryCount) {\n          console.log(`Retry attempt ${attempts}/${retryCount} after error: ${error.message}`);\n          return new Promise(resolve => setTimeout(resolve, retryDelay))\n            .then(executeWithRetry);\n        }\n        throw error; // If all retries fail, propagate the error\n      });\n    };\n  \n    return executeWithRetry();\n  }\n\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === \"generate_password\") {\n        // Send the request to the backend to generate a password\n        fetch('http://localhost:8000/password/generate', {\n            method: 'GET',  // Or POST if necessary, depending on your backend setup\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        })\n            .then((response) => response.json())  // Assuming the backend returns a JSON response\n            .then((data) => {\n                if (data.password) {\n                    // Send the generated password to the popup\n                    sendResponse({ password: data.password });\n                } else {\n                    sendResponse({ error: 'Failed to generate password' });\n                }\n            })\n            .catch((error) => {\n                console.error('Error generating password:', error);\n                sendResponse({ error: 'Failed to contact backend' });\n            });\n\n        // Keep the response channel open until the async operation finishes\n        return true;\n    }\n\n    if (message.action === \"login\") {\n        // Forward the login request to the Backend\n        const loginData = new URLSearchParams();\n        loginData.append(\"username\", message.email);\n        loginData.append(\"password\", message.masterPassword);\n\n        fetch('http://localhost:8000/auth/login', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n            body: loginData.toString(),\n        })\n        .then(response => response.json())\n        .then(data => {\n            if (data.access_token) {\n                // Store the token in chrome storage for later use\n                const expiresIn = data.expires_in || 3600; // Default to 1 hour if not provided\n                chrome.storage.local.set({ \n                    authData: {\n                        token: data.access_token,\n                        expires: Date.now() + (expiresIn * 1000),\n                        refreshToken: data.refresh_token || null\n                    }\n                }, () => {\n                    console.log(\"Token stored successfully.\");\n                });\n\n                sendResponse({ success: true, token: data.access_token });\n            } else {\n                sendResponse({ success: false, error: data.detail || \"Login failed\" });\n            }\n        })\n        .catch(error => {\n            console.error(\"Login error:\", error);\n            sendResponse({ success: false, error: \"Failed to contact backend\" });\n        });\n\n        return true; // Keep response channel open\n    }\n    if (message.action === 'saveCredentials') {\n        // Get the credentials from the message\n        const credentials = message.data;\n        \n        // First get the token, then use it in the fetch request\n        getAuthToken()\n            .then(token => {\n                // Send to your backend with the token\n                return fetch('http://localhost:8000/vault/passwords', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': 'Bearer ' + token\n                    },\n                    body: JSON.stringify(credentials)\n                });\n            })\n            .then(response => {\n                // Check if response is OK before parsing JSON\n                if (!response.ok && response.status !== 200) {\n                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);\n                }\n                return response.json();\n            })\n            .then(data => {\n                // Check if the response contains a duplicate message\n                if (data.message === \"Password already saved!\") {\n                    sendResponse({ \n                        success: true, \n                        message: 'Password already saved!' \n                    });\n                } else {\n                    sendResponse({ \n                        success: true, \n                        message: 'Credentials saved successfully' \n                    });\n                }\n            })\n            .catch(error => {\n                console.error('Error saving credentials:', error);\n                sendResponse({ \n                    success: false, \n                    message: 'Failed to save credentials' \n                });\n            });\n        \n        // Required for async response\n        return true;\n    }\n\n    if (message.action === \"getCredentials\") {\n        const site = message.site;\n        \n        // Get auth token first, then fetch credentials\n        getAuthToken()\n          .then(token => {\n            return fetch(`http://localhost:8000/vault/passwords?site=${encodeURIComponent(site)}`, {\n              method: 'GET',\n              headers: {\n                'Authorization': `Bearer ${token}`\n              }\n            });\n          })\n          .then(response => {\n            if (!response.ok) {\n              throw new Error(`Server returned ${response.status}: ${response.statusText}`);\n            }\n            return response.json();\n          })\n          .then(data => {\n            sendResponse({ \n              success: true, \n              credentials: data \n            });\n          })\n          .catch(error => {\n            console.error(\"Error fetching credentials:\", error);\n            sendResponse({ \n              success: false, \n              error: error.message \n            });\n          });\n        \n        return true; // Keep channel open for async response\n      }\n});"],"names":["enabled","text","chrome","action","setBadgeText","input","value","disabled","readOnly","nativeInputValueSetter","Object","getOwnPropertyDescriptor","window","HTMLInputElement","prototype","set","call","forEach","eventType","event","KeyboardEvent","bubbles","cancelable","key","Event","dispatchEvent","focus","setTimeout","blur","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","getAuthToken","options","autoRefresh","retryCount","retryDelay","attempts","executeWithRetry","Promise","resolve","reject","storage","local","get","result","runtime","lastError","console","error","message","Error","authData","token","expires","Date","now","refreshToken","log","catch","then","onMessage","addListener","sender","sendResponse","fetch","method","headers","response","json","data","password","loginData","URLSearchParams","append","email","masterPassword","body","toString","access_token","expiresIn","expires_in","refresh_token","success","detail","credentials","JSON","stringify","ok","status","statusText","site","encodeURIComponent"],"sourceRoot":""}